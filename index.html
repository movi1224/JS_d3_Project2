<html>

<head>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">
  <style>
    .country {
      fill: gray;
    }

    .outline {
      stroke: #fff;
      stroke-width: 1px;
      fill: none;
    }

    .mouseover {
      stroke-width: 3px;
      pointer-events: none;
    }

    .graticule {
      stroke: #ddd;
      stroke-width: 1px;
      fill: none;
    }

    #float-button-group {
      position: fixed;
      left: 10;
      opacity: 0.5;
    }

    #float-button-group:hover {
      opacity: 1;
    }

    #map-zoomer {
      position: absolute;
      writing-mode: bt-lr;
      -webkit-appearance: slider-vertical;
      width: 8px;
      height: 100px;
      padding: 0 5px;
      position: absolute;
      top: 125px;
      left: 25px;
    }
  </style>
</head>

<body>
  <p>Project2</p>
  <div id="map">
    <div class="btn-group-vertical" role="group" id="float-button-group">
      <button type="button" class="btn btn-default" id="in"><span class="glyphicon glyphicon-zoom-in"
          aria-hidden="true"></span></button>
      <button type="button" class="btn btn-default" id="out"><span class="glyphicon glyphicon-zoom-out"
          aria-hidden="true"></span></button>
      <button type="button" class="btn btn-default" id="reset"><span class="glyphicon glyphicon-screenshot"
          aria-hidden="true"></span></button>
    </div>
    <input type="range" value="1" min="1" max="8" orient="vertical" id="map-zoomer" />

  </div>
  <svg id="worldmap" height="610" width="960"></svg>

  <script>
    // Fast food map
    const svg = d3.select("#worldmap");
    const width = svg.attr("width");
    const height = svg.attr("height");
    const mapWidth = width;
    const mapHeight = height;
    // No margins here since our US map already has a specific projection to match to size
    const map = svg.append("g");

    const requestData1 = async function () {

      const world = await d3.json("countries-110m.json");

      var countries = topojson.feature(world, world.objects.countries);
      var countriesMesh = topojson.mesh(world, world.objects.countries);
      var projection = d3.geoMercator() //geoNaturalEarth1
      var path = d3.geoPath().projection(projection);

      var graticule = d3.geoGraticule10();
      map.append("path").attr("class", "graticule").attr("d", path(graticule));

      // 1. Draw nation and state outlines
      map.selectAll("path.country").data(countries.features)
        .join("path")
        .attr("class", "country")
        .attr("id", d => d.id)
        // .on("click", clicked)
        .attr("d", path);

      map.append("path").datum(countriesMesh)
        .attr("class", "outline")
        .attr("d", path);

      // 2. Add tooltips to show the name of the country
      let tooltipWidth = 120;
      let tooltipHeight = 40;

      let tooltip = map.append("g")
        .attr("class", "tooltip")
        .attr("visibility", "hidden");

      tooltip.append("rect")
        .attr("fill", "black")
        .attr("opacity", 0.9)
        .attr("x", -tooltipWidth / 2.0)
        .attr("y", 0)
        .attr("width", tooltipWidth)
        .attr("height", tooltipHeight);

      let txt = tooltip.append("text")
        .attr("fill", "white")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 0)
        .attr("y", 2);

      // mouseover outline
      let momesh = map.append("path")
        .attr("class", "mouseover outline")
        .attr("d", "");

      d3.selectAll(".country").on("mouseenter", mouseEnters) // mouseover to show tooltips
      d3.selectAll(".country").on("mouseout", mouseLeaves)

      function mouseEnters() {
        // Make tooltip visible
        tooltip.style("visibility", "visible")
        // Find the state SVG element and add stroke
        let country = d3.select(this);
        let ctID = country.datum().id;
        let ctName = country.datum().properties.name;
        console.log(country.datum().properties.name)
        //  First, make a new mesh with a filter for only borders of the current state
        var mo = topojson.mesh(world, world.objects.countries, function (a, b) { return a.id === ctID || b.id === ctID; });
        //  Then apply it to your special mesh that's on top of everything else
        momesh.datum(mo).attr("d", path)
        txt.text("ctName");

        let bounds = path.bounds(country.datum());   // Get the pixel boundaries of the state
        // Place it at the bottom of the state, centered
        let xPos = (bounds[0][0] + bounds[1][0]) / 2.0;
        let yPos = bounds[1][1];
        console.log(xPos, yPos)

        // Transform the <g> group so that everything moves together easily
        tooltip.attr("transform", `translate(${xPos},${yPos})`);
      }

      function mouseLeaves() {
        // Hide when you leave a state
        tooltip.style("visibility", "hidden");
        let country = d3.select(this);
        // Reset old style mouseover stroke
        // state.attr("stroke","none")
        //      .attr("stroke-width", 0);
        // }
        // Here we are hiding the mouseover mesh we added at the end of the lecture
        momesh.attr("d", "");

      }

      // 3. Zoom-in & zoom-out features with the slider
      const zoom = d3.zoom() // initiate d3-zoom
        .scaleExtent([1, 5])
        .on("zoom", zoomed);

      svg.call(zoom);

      function zoomed(event) {
        const { transform } = event;
        map.attr("transform", transform);
        slider.property("value", transform.k);
        // console.log(transform)
      }

      // function clicked(event, d) {
      //   const [[x0, y0], [x1, y1]] = path.bounds(d);
      //   event.stopPropagation();
      //   contries.transition().style("fill", null);
      //   d3.select(this).transition().style("fill", "red");
      //   svg.transition().duration(750).call(
      //     zoom.transform,
      //     d3.zoomIdentity
      //       .translate(mapWidth / 2, mapHeight / 2)
      //       .scale(Math.min(8, 0.9 / Math.max((x1 - x0) / mapWidth, (y1 - y0) / mapHeight)))
      //       .translate(-(x0 + x1) / 2, -(y0 + y1) / 2),
      //     d3.pointer(event, svg.node())
      //   );
      // }

      // reset to original scale
      function reset() {
        svg.transition().duration(750).call(
          zoom.transform,
          d3.zoomIdentity,
          d3.zoomTransform(svg.node()).invert([mapWidth / 2, mapHeight / 2])
        );
        // console.log('identity',d3.zoomIdentity)
      }

      // create a slider that zoom-in and zoom-out the map
      var slider = d3.select("#map-zoomer")
        .datum({})
        .attr("type", "range")
        .attr("value", zoom.scaleExtent()[0])
        .attr("min", zoom.scaleExtent()[0])
        .attr("max", zoom.scaleExtent()[1])
        .attr("step", (zoom.scaleExtent()[1] - zoom.scaleExtent()[0]) / 100)
        .on("input", slided);

      function slided(d) {
        svg.transition().call(zoom.scaleTo, d3.select(this).property("value"));
      }

      d3.select('#in').on('click', () => {
        svg.transition().call(zoom.scaleBy, 1.2)
      });

      d3.select('#out').on('click', () => {
        svg.transition().call(zoom.scaleBy, 0.8)
      });

      d3.select('#reset').on('click', reset);


      // 4. Import data
      var tempData = await d3.csv("Temperature.csv");
      tempData = tempData.filter(d => d['AverageTemperature'] !== "");
      // console.log(tempData)
      tempData.sort((x, y) => {
        return d3.ascending(x.Country, y.Country);
      })
      console.log(tempData)
      var countries = [];
      tempData.forEach((d, i) => {
        if (d.Country != countries[0]) {
          countries.splice(0, 0, d.Country);
        }
      })
      var ctMap = {};
      countries.forEach((d, i) => {
        ctMap[i] = d;
      })
      // console.log(ctMap)



      // No counties this time


      // // Now import our fastfood dataset
      // var fastfood = await d3.csv("fastfood.csv", d3.autoType);
      // // console.log(fastfood)

      // // We're going to draw contours today. For contours, working by PIXEL
      // // coords rather than lat/lng is going to be the best approach 
      // // We do the same conversion as we did in the dot chart...
      // fastfood.forEach( (d, i) => {
      //   // Use the projection just like a scale to convert from lng/lat to pixels
      //   d.position = projection( [d.longitude, d.latitude] );
      //   // console.log(d.position)
      // });



      // // ** Make a contour generator **
      // // You'll see two kinds in the documentation, d3.contour() and d3.contourDensity
      // // -Use d3.contour when you have *values* spread across space and want to show them
      // // -Use contourDensity when you have *points* spread over space and want to show
      // //   *how many* there are in a given location compared to other locations
      // // Like other shape generators, you're programming a function that takes in a
      // //  dataset and does something fancy to it to generate shapes
      // let contourGen = d3.contourDensity()
      //                    .x( d => d.position[0] )        // point x position (best in pixels)
      //                    .y( d => d.position[1] )        // point y position (best in pixels)
      //                    .size( [width, height] )    // size of canvas
      //                    .thresholds( 10 );              // number of "levels" you want

      // // Now run the contour generator on your dataset
      // let contours = contourGen(fastfood);

      // // Check out what kind of data you get...
      // console.log(contours)
      // // It's actually a topoJSON featureCollection!
      // // A contour generator creates fake geographic data to use to draw contours
      // // We know how to work with these kinds of things...

      // // Let's make a color scale for the density contours
      // // Our topoJSON has an extra key for each feature, value, that is the density
      // //  value for that particular contour in the list -- we can use extent to figure
      // //  out the min and max density levels so we can apply a color scale
      // let valueExtent = d3.extent(contours, d => d.value);
      // let colorScale = d3.scaleSequential(d3.interpolateViridis).domain(valueExtent)

      // let layer = map.append("g");

      // // Sidenote: The array of features that contourDensity gives you have been carefully
      // //  ordered so that the big, low density ones will be earlier in the list -- this
      // //  guarantees that they'll be drawn *underneath* the higher densities in a join
      // layer.selectAll("path.contours")
      //       .data(contours)
      //       .join("path")
      //       .attr("class", 'contours')
      //       .attr("fill", d => colorScale(d.value) )
      //       .attr("d", d3.geoPath())  
      //         // NOTE: We create a new d3.geoPath because we have already converted our 
      //         //  locations into pixels. We don't need a projection in our geoPath now

      // // But how do we make sure the user can still see the map details and state borders?
      // // layer.attr("opacity", 0.5)   // This doesn't work too well to show map details...

      // // Better is to layer some stuff on top of the contours!
      // map.append("path").datum(countriesMesh)
      //       .attr("class","outline")
      //       .attr("opacity", 0.5)
      //       .attr("d", path);

      // // // We can show the circles to see whether our densities are plausible
      // // ffmap.selectAll("circle.dot").data(fastfood)
      // //      .join("circle")
      // //      .attr("class","dot")
      // //      .attr("r", 2)
      // //      .attr("fill", "darkgrey")
      // //      .attr("opacity", 0.2)
      // //      .attr("cx", d => d.position[0])
      // //      .attr("cy", d => d.position[1]);


    }
    requestData1();
  </script>
</body>

</html>