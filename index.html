<html>

<head>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">
  <style>
    * {
      box-sizing: border-box;
    }

    .header {
      padding: 15px;
      text-align: left;
      font-size: 45;
      font-weight: 800;
      font-family: 'Arial', sans-serif;
    }

    .column {
      float: left;
      padding: 10px;
      height: 800px;
    }

    .column.left {
      background-color: whitesmoke;
      width: 38%;
    }

    .column.right {
      padding-left: 25px;
      background-color: white;
      width: 62%;
    }

    .content:after {
      content: "";
      display: table;
      clear: both;
    }

    @media (max-width: 1000px) {

      .column.left,
      .column.right {
        width: 100%;
      }
    }

    #main_map {
      float: left;
    }

    #worldmap {
      border-style: solid;
      border-width: 1px;
    }

    .country {
      transition: fill 0.5s;
    }

    #legend {
      /* margin-left: 10px; */
      float: left;
    }

    #float-button-group {
      margin-top: 7px;
      margin-left: 7px;
      position: absolute;
    }

    #map-zoomer {
      position: absolute;
      writing-mode: bt-lr;
      -webkit-appearance: slider-vertical;
      width: 8px;
      height: 100px;
      margin-top: 100px;
      margin-left: 24px;
    }

    .zoom-tools {
      transition: opacity 0.5s;
      opacity: 0.5;
    }

    .zoom-tools:hover {
      opacity: 1;
    }

    .tick line {
      color: #dddddd;
    }

    .track .track-inset,
    .track-overlay {
      stroke-linecap: round;
    }

    .track {
      stroke: #000;
      stroke-opacity: 0.3;
      stroke-width: 10px;
    }

    .track-inset {
      stroke: #dcdcdc;
      stroke-width: 8px;
    }

    .track-overlay {
      pointer-events: stroke;
      stroke-width: 50px;
      stroke: transparent;
      cursor: crosshair;
    }

    .handle {
      fill: #fff;
      stroke: #000;
      stroke-opacity: 0.5;
      stroke-width: 1.25px;
    }

    .country {
      fill: gray;
    }

    .outline {
      stroke: #fff;
      stroke-width: 1px;
      fill: none;
    }

    .mouseover {
      stroke-width: 3px;
      pointer-events: none;
    }

    .graticule {
      stroke: #eee;
      stroke-width: 1px;
    }

    .co2bar {
      margin-left: 52px
    }

    .tool_tip {
      padding: 10px;
      width: 100%;
      height: 20%;
    }

    g.tooltip {
      opacity: 1;
    }

    g.tooltip rect {
      width: 480;
      fill: whitesmoke;
      stroke: #222;
      stroke-width: 1px;
    }

    g.tooltip text {
      font-size: 20px;
      font-family: Arial, sans-serif;
    }

    #season-button-group {
      opacity: 0;
      position: fixed;
      left: 20;
      bottom: 260;
    }

    #season-button-group:hover {
      opacity: 1;
    }
  </style>
</head>

<body>
  <div class="header">
    <p>GLOBAL TEMPERATURE CHANGE AND CARBON DIOXIDE EMISSION</p>
  </div>

  <div class="content">
    <div class="column left">
      <svg class="tool_tip"></svg>
      <div class="co2bar">
        <svg id="co2" height="27"></svg>
      </div>
      <div id="line_chart" style="text-align: center;"></div>
      <div class="btn-group-horizontal" role="group" id="season-button-group">
        <button type="button" class="btn btn-default" id="winter"><span aria-hidden="true">Jan-Mar</span></button>
        <button type="button" class="btn btn-default" id="spring"><span aria-hidden="true">Apr-June</span></button>
        <button type="button" class="btn btn-default" id="summer"><span aria-hidden="true">Jul-Sep</span></button>
        <button type="button" class="btn btn-default" id="autumn"><span aria-hidden="true">Oct-Dec</span></button>
        <button type="button" class="btn btn-default" id="resetSeason"><span aria-hidden="true">Whole
            Year</span></button>
      </div>
    </div>

    <div class="column right">
      <div id="slider"></div>
      <div id="main_map">
        <div class="zoom-tools">
          <div class="btn-group-vertical" role="group" id="float-button-group">
            <button type="button" class="btn btn-default" id="in"><span class="glyphicon glyphicon-zoom-in"
                aria-hidden="true"></span></button>
            <button type="button" class="btn btn-default" id="out"><span class="glyphicon glyphicon-zoom-out"
                aria-hidden="true"></span></button>
            <button type="button" class="btn btn-default" id="reset"><span class="glyphicon glyphicon-screenshot"
                aria-hidden="true"></span></button>
          </div>
          <input id="map-zoomer" type="range" value="1" min="1" max="8" orient="vertical" />
        </div>
        <svg id="worldmap" height="610" width="880"></svg>
      </div>
      <div id="legend">
        <svg id="colorLegend" height="650" width="60" style="background: #fff;"></svg>
      </div>
    </div>

  </div>


  <script>
    // World map
    const svg = d3.select("#worldmap");
    const width = svg.attr("width");
    const height = svg.attr("height");
    const mapWidth = width;
    const mapHeight = height;
    // No margins here since our US map already has a specific projection to match to size
    const map = svg.append("g");


    // Format the date in the data
    var formatDateIntoYear = d3.timeFormat("%Y");
    var formatDate = d3.timeFormat("%b %Y");
    var parseDate = d3.timeParse("%y-%m-%d");
    const DEFAULT_DATE = formatDateIntoYear(new Date("1980-02-01"));
    var curYear = new Date("1980-02-01");
    var curStartMonth = null;
    var curEndMonth = null;

    const requestData1 = async function () {

      ///////////////////////////////////////////////// 
      // 1. Draw a map of all countries using topoJSON
      /////////////////////////////////////////////////

      // Import topoJSON data file
      const world = await d3.json("countries-110m.json");

      // Pick out topographic features and build d3 helpers
      var countries = topojson.feature(world, world.objects.countries);  // countries.features stores all the geo info of the countries in topojson
      var countriesMesh = topojson.mesh(world, world.objects.countries);
      var projection = d3.geoMercator().scale(150)
        .translate([width / 2, height / 2]); //geoMercator() //geoNaturalEarth1
      var path = d3.geoPath().projection(projection);

      var graticule = d3.geoGraticule10();       // Add a graticule
      map.append("path").attr("class", "graticule").attr("d", path(graticule));

      // Draw countries and outlines
      map.selectAll("path.country").data(countries.features)  // countries
        .join("path")
        .attr("class", "country")
        .attr("id", d => d.id)
        // .on("click", clicked)
        .attr("d", path);

      map.append("path").datum(countriesMesh) // outlines
        .attr("class", "outline")
        .attr("d", path);

      /////////////////////////////////////////////////
      // 2. Import data
      /////////////////////////////////////////////////
      var tempData = await d3.csv("Temperature.csv");
      var co2Data = await d3.csv("CO2.csv");
      var countryData = await d3.csv("data generation/tempData_Aggretate.csv");

      console.log(countryData)

      // Get all year's temperature data in each country
      var allgeoCountries = [];
      countries.features.forEach(row => {
        allgeoCountries.push(row.properties.name)
      })
      countries_temps = {}; // { country name : minMax of the country's all year's average temperature}
      countryData.forEach(d => {
        var country = d.Country;
        var temp_list;
        // make a map of each country and a list of all its temperatures in a year 
        if (!(country in countries_temps)) {
          // take all the temperatrues of a country in a  list
          temp_list = [];
          temp_list.push(Number(Number(d.mean).toFixed(2)));
          countries_temps[country] = temp_list;
        } else {
          temp_list = countries_temps[country];
          temp_list.push(Number(Number(d.mean).toFixed(2)));
          countries_temps[country] = temp_list; // { country name : a list of the country's all year's average temperature}
        }
      })

      // Object.keys(countries_temps).forEach(function (key) {
      //   countries_temps[key] = d3.extent(countries_temps[key]);
      // });

      console.log(countries_temps)
      var tempDataConst = tempData;


      tempData = tempData.filter(function (d) { return new Date(d.dt) < new Date("2013-01-01"); });
      co2Data = co2Data.filter(function (d) { return new Date(d.Year) < new Date("2013-01-01"); });

      // Get global average temperature by year
      var tempDataAvgByYear = d3.rollup(tempData,
        v => d3.mean(v, d => d.AverageTemperature),
        d => formatDateIntoYear(new Date(d.dt)));

      tempDataAvgByYear = Array.from(tempDataAvgByYear, ([year, temperature]) => ({ year, temperature }));
      // remove 1979 date
      tempDataAvgByYear.shift();
      // console.log(tempDataAvgByYear);
      // console.log(co2Data);

      var co2;
      co2Data.forEach((d) => {
        if (DEFAULT_DATE == d.Year) {
          co2 = d.CO2_concentrations;
        }
        d.dt = new Date(d.dt);
      })

      var co2Extent = d3.extent(co2Data, d => d.CO2_concentrations);
      const colorScale2 = d3.scaleSequential(d3.interpolateYlOrBr).domain([co2Extent[0] - 40, co2Extent[1]]);
      const lengthScale = d3.scaleLinear().domain(co2Extent).range([250, 450]);
      drawCO2Bar(co2, lengthScale, colorScale2)

      /////////////////////////////////////////////////
      // line chart
      /////////////////////////////////////////////////
      const lineChartMargin = { top: 10, right: 60, bottom: 40, left: 60 };
      const lineChartWidth = 600 - lineChartMargin.left - lineChartMargin.right;
      const lineChartHeight = 500 - lineChartMargin.top - lineChartMargin.bottom;


      const lineChart = d3.select("#line_chart")
        .append("svg")
        .attr("width", lineChartWidth + lineChartMargin.left + lineChartMargin.right)
        .attr("height", lineChartHeight + lineChartMargin.top + lineChartMargin.bottom)
        .append("g")
        .attr("transform",
          "translate(" + (lineChartMargin.left + 5) + "," + lineChartMargin.top + ")");

      // year scale used in the line chart
      var yearScale = d3.scaleTime()
        .domain(d3.extent(co2Data, d => d.Year))
        .range([0, lineChartWidth]);

      var firstyearScale = d3.scaleTime()
        .domain([DEFAULT_DATE, DEFAULT_DATE])
        .range([0, lineChartWidth]);

      // lineChart.append("g") // bottom axis
      //   .attr("transform", "translate(0," + (lineChartHeight + 5) + ")")
      //   .call(d3.axisBottom(yearScale).ticks(17).tickSizeOuter(0).tickFormat(d3.format("d")));

      lineChart.append("g") // bottom axis
        .attr("class", "x axis")
        .attr("transform", "translate(0," + (lineChartHeight + 5) + ")")
        .call(d3.axisBottom(firstyearScale).ticks(1).tickSizeOuter(0).tickFormat(d3.format("d")));

      // lineChart.append("text") // left y axis label
      //   .attr("class", "label")
      //   .attr("text-anchor", "end")
      //   .attr("x", -150)
      //   .attr("y", -50)
      //   .attr("dy", ".75em")
      //   .attr("transform", "rotate(-90)")
      //   .text("CO2 Emission");

      // lineChart.append("text") // x axis label
      //   .attr("class", "label")
      //   .attr("text-anchor", "end")
      //   .attr("x", lineChartWidth / 2)
      //   .attr("y", lineChartHeight + 30)
      //   .text("year");

      // lineChart.append("g") // left y axis tick
      //   .attr("transform", "translate(-5,0)")
      //   .call(d3.axisLeft(co2Scale).tickSizeOuter(0).tickFormat(d3.format("d")));

      var co2Scale = d3.scaleLinear()
        .domain(d3.extent(co2Data, d => d.CO2_concentrations))
        .range([lineChartHeight, 0]);

      var initialco2Data = co2Data.filter(function (d) { return new Date(d.Year) <= new Date("1980"); });
      console.log(co2Data)

      var initialco2Scale = d3.scaleLinear()
        .domain(d3.extent(initialco2Data, d => d.CO2_concentrations))
        .range([lineChartHeight, 0]);
      var initialyearScale = d3.scaleTime()
        .domain(d3.extent(initialco2Data, d => d.Year))
        .range([0, lineChartWidth]);

      lineChart.selectAll("co2circle")
        .data(initialco2Data)
        .join("circle")
        .attr("class", "co2circle")
        .attr("r", 3)
        .attr("fill", "#823b0e")
        .attr("cx", d => initialyearScale(d.Year))
        .attr("cy", d => initialco2Scale(d.CO2_concentrations));

      lineChart.append("g")
        .attr("class", "co2_axis")
        .call(d3.axisLeft(initialco2Scale).tickSizeOuter(0).tickFormat(function (d) { return d + " ppm" }))
        .call(g => g.selectAll(".tick line").attr("stroke-opacity", 0));

      lineChart.append("g").lower()
        .attr("class", "y gridlines")
        .call(d3.axisLeft(initialco2Scale).tickFormat("").tickSize(-lineChartWidth));

      var tempScale = d3.scaleLinear()
        .domain(d3.extent(tempDataAvgByYear, d => d.temperature))
        .range([lineChartHeight, 0]);

      var initialtempData = tempDataAvgByYear.filter(function (d) { return new Date(d.year) <= new Date("1980"); });
      console.log(tempDataAvgByYear)
      // initialtempData = initialtempData.filter(d => d['AverageTemperature'] !== ""); // filter out blank data
      // Get global average temperature by year
      // var initialtempDataAvgByYear = d3.rollup(initialtempData,
      //   v => d3.mean(v, d => d.AverageTemperature),
      //   d => formatDateIntoYear(new Date(d.dt)));
      // initialtempDataAvgByYear = Array.from(initialtempDataAvgByYear, ([year, temperature]) => ({ year, temperature }));
      // // remove 1979 date
      // initialtempDataAvgByYear.shift();

      var initialtempScale = d3.scaleLinear()
        .domain(d3.extent(initialtempData, d => d.temperature))
        .range([lineChartHeight, 0]);

      // lineChart.append("g")
      //   .attr("transform", "translate(" + (lineChartWidth + 5) + ",0)")
      //   .call(d3.axisRight(tempScale).tickSizeOuter(0));

      lineChart.append("g")
        .attr("class", "temp_axis")
        .attr("transform", "translate(" + (lineChartWidth) + ",0)")
        .call(d3.axisRight(initialtempScale).tickSizeOuter(0).tickFormat(function (d) { return d3.format(",.2~f")(d) + "\u2103" }))
        .call(g => g.selectAll(".tick line").attr("stroke-opacity", 0));

      lineChart.selectAll("temp_circle")
        .data(initialtempData)
        .join("circle")
        .attr("class", "temp_circle")
        .attr("r", 3)
        .attr("fill", "#09604c")
        .attr("cx", lineChartWidth / 2)
        .attr("cy", lineChartHeight / 2);

      // lineChart.append("text")
      //   .attr("class", "label")
      //   .attr("text-anchor", "end")
      //   .attr("x", 220)
      //   .attr("y", -lineChartWidth - 45)
      //   .attr("dy", ".75em")
      //   .attr("transform", "rotate(90)")
      //   .text("Avg Temperature");


      // lineChart.append("path")
      //   .datum(co2Data)
      //   .attr("fill", "none")
      //   .attr("stroke", "#69b3a2")
      //   .attr("stroke-width", 4)
      //   .attr("d", d3.line()
      //     .x(function (d) { return yearScale(d.Year) })
      //     .y(function (d) { return co2Scale(d.CO2_concentrations) })
      //   );

      // lineChart.append("path")
      //   .datum(tempDataAvgByYear)
      //   .attr("fill", "none")
      //   .attr("stroke", "#FFDA33")
      //   .attr("stroke-width", 4)
      //   .attr("d", d3.line()
      //     .x(function (d) { return yearScale(d.year) })
      //     .y(function (d) { return tempScale(d.temperature) })
      //     .curve(d3.curveBasis)
      //   );

      // lineChart.append("line")
      //   .attr("id", "vert-line")
      //   .attr("x1", yearScale(DEFAULT_DATE))
      //   .attr("y1", 0)
      //   .attr("x2", yearScale(DEFAULT_DATE))
      //   .attr("y2", lineChartHeight + 5)
      //   .style("stroke-width", 2)
      //   .style("stroke", "grey")
      //   .style("fill", "none");


      // lineChart.append("circle").attr("cx", 40).attr("cy", 60).attr("r", 6).style("fill", "#69b3a2");
      // lineChart.append("circle").attr("cx", 40).attr("cy", 90).attr("r", 6).style("fill", "#FFDA33");
      // lineChart.append("text").attr("x", 60).attr("y", 60).text("CO2 Emission").style("font-size", "15px").attr("alignment-baseline", "middle");
      // lineChart.append("text").attr("x", 60).attr("y", 90).text("Avg Temperature").style("font-size", "15px").attr("alignment-baseline", "middle");
      lineChart.append("circle").attr("cx", 20).attr("cy", 10).attr("r", 3).style("fill", "#823b0e");
      lineChart.append("text").attr("x", 40).attr("y", 10).text("CO2 Emission").style("font-size", "12px").attr("alignment-baseline", "middle");
      lineChart.append("circle").attr("cx", 20).attr("cy", 25).attr("r", 3).style("fill", "#09604c");
      lineChart.append("text").attr("x", 40).attr("y", 25).text("Avg Temperature").style("font-size", "12px").attr("alignment-baseline", "middle");

      // End of line chart

      /////////////////////////////////////////////////
      // Temperature data in each year
      /////////////////////////////////////////////////
      tempData = tempData.filter(d => d['AverageTemperature'] !== ""); // filter out blank data

      tempData.sort((x, y) => {
        return d3.ascending(x.Country, y.Country);
      })

      var all_countries = [];
      var country_avgTemp = {};


      curFilteredData = tempData.filter(function (d) {
        return d.dt >= DEFAULT_DATE && d.dt < DEFAULT_DATE + 1;
      })
      // let filterFunc = d => d["dt"] <= data;
      // tempData = tempData.filter( d => pointPassesFilters(d) ); 
      curFilteredData.forEach((d, i) => {
        var country = d.Country;
        // make a list of all the countries
        if (country != all_countries[0]) {
          all_countries.splice(0, 0, country);
        }
        // make a map of each country and a list of all its temperatures in a year 
        if (!(country in country_avgTemp)) {
          // take all the temperatrues of a country in a  list
          var temperature_list = [];
          temperature_list.push(d.AverageTemperature);
          country_avgTemp[country] = temperature_list;
        } else {
          temperature_list = country_avgTemp[country];
          temperature_list.push(d.AverageTemperature);
          country_avgTemp[country] = temperature_list;
        }
      });

      // Use the temperature list to calculate the average temperature in a year of each country
      Object.keys(country_avgTemp).forEach(function (key) {
        temperature_list = country_avgTemp[key];
        var total = 0;
        for (i = 0; i < temperature_list.length; i++) {
          total += Number(temperature_list[i]);
        }
        country_avgTemp[key] = total / temperature_list.length;
      });

      ///////////////////////////////////////////////////
      ///////// Generate the data we will use ///////////
      ///////////////////////////////////////////////////
      var countryTemp = {}; // countryTemp[ countryName ] -> count
      var countryMinMax = {};
      var cnt = [];
      var idToCountry = {}  // idToCountry[ countryID ] -> CountryName

      // make a list of pairs of country names and its id, to fit the location in the geoJSON
      countries.features.forEach(row => {
        cnt.push({ id: row.id, name: row.properties.name })
        countryTemp[row.properties.name] = 0;
        if (all_countries.indexOf(row.properties.name) != -1) {
          idToCountry[row.id] = row.properties.name;
        }
        else { console.log(row.properties.name) }
      });

      cnt.forEach(row => {
        Object.keys(country_avgTemp).forEach(function (key) {
          if (key === row.name) {
            row.temperature = country_avgTemp[key].toFixed(2);
          }
        })
        row.temperature = Number(row.temperature)
        Object.keys(countries_temps).forEach(function (key) {
          if (key === row.name) {
            row.temp_mimMax = countries_temps[key];
          }
        })
      });

      console.log(cnt)

      // fiter out the data with no information on temperature and id
      // cnt = cnt.filter(d => d['temperature'] && d['id']);

      cnt.forEach(row => {
        countryTemp[row.name] = row.temperature;
        countryMinMax[row.name] = row.temp_mimMax;
      })

      // Make a d3 color scale for frequency    
      console.log(tempData);
      // Make a d3 color scale for frequency    
      var minMax = d3.extent(cnt, d => countryTemp[d.name]);
      console.log(minMax)

      var colors = [
        "#0054c9", "#1161d1", "#206cd6", "#3078db", "#3e81de", "#4987de", "#4987de", "#6297e3", "#73a2e6", "#84ade8", "#96b9eb", "#a6c3ed", "#b6cef0", "#c4d7f2", "#d7e4f7", "#e6f0ff", "#fff5f5", "#fae3e3", "#f5d0d0", "#edbbbb", "#e8acac", "#e89e9e", "#e38f8f", "#db7979", "#db6969", "#d45757", "#c74242", "#c23434", "#c42727", "#ba1a1a", "#b31212", "#ad0909"
      ]

      var cScale = t => d3.interpolateRdBu(1 - t)
      var color = d3.scaleLinear().domain([10, 100]).range(["brown", "steelblue"]);
      var colorData = [];
      for (var i = 0; i < 34; i++) {
        colorData.push(i)
      }
      console.log(colorData)
      // var colorScale = d3.scaleSequential(colors).domain(minMax);
      var colorScale = d3.scaleLinear().domain(colorData).range(colors)
      console.log(colorScale)

      // countries.features.forEach(d => {
      //   console.log(countryMinMax[idToCountry[d.id]])
      // })

      // const colorScale = d3.scaleQuantile()
      //   .domain(Object.values(stateCounts))
      //   .range(["#fff", "#d1e8ed", "#adc2da", "#8879b3", "#762b80"]);


      map.selectAll(".country")
        .style("fill", d => {
          if (idToCountry[d.id]) {
            return d3.scaleQuantile()
              .domain(countryMinMax[idToCountry[d.id]])
              .range(colors)(countryTemp[idToCountry[d.id]]);
          }
        });

      // map.selectAll("path.country").data(cnt)  // countries
      //   .join("path")
      //   .attr("class", "country")
      //   .style("fill", d => d3.scaleSequential(d3.interpolateRdBu).domain(d.temp_mimMax) )
      //   // .on("click", clicked)
      //   .attr("d", path);

      // var colors = ["#3c89d0", "#88c7dc", "#66c2a5", "#abdda4", "#e6f598", "#ffffbf", "#fee08b", "#fdae61", "#f46d43", "#d53e4f", "#9e0142"];

      // var colorScale = d3.scaleQuantile()
      //   .domain(Object.values(countryTemp))
      //   .range(colors);

      // Recolor the states to make a choropleth map
      // map.selectAll(".country")
      //   .style("fill", d => colorScale(countryTemp[idToCountry[d.id]]));

      // Use the extra legend code to draw a legend
      drawLegend(d3.select("#colorLegend"), colorScale);

      function changeMonthDays(d, qty) {
        var dd = d.getDate();
        var mm = d.getMonth();
        var yyyy = d.getFullYear();
        return new Date(yyyy, qty, 1);
      }

      ///////////////////////////////////////
      //////// Update function
      ///////////////////////////////////////
      function update(year, startMonth = undefined, endMonth = undefined) {
        // remove the existing element to prevent the overlap on drawing
        // d3.select('#colorLegend')
        //   .selectAll('*')
        //   .remove();

        lineChart.select("g.x.axis").remove();

        d3.select('#co2')
          .selectAll('*')
          .remove();

        d3.selectAll("line#vert-line")
          .remove();

        handle.attr("cx", x(year)); // make the handler of the slider goes with curosr
        label.attr("x", x(year)).text(Number(formatDateIntoYear(year)) + 1); // make the label of the  year goes with the handler
        year = formatDateIntoYear(year);

        if (startMonth != null) {
          startTime = changeMonthDays(year, startMonth);
          endTime = changeMonthDays(year, endMonth);
          console.log(startTime);
          console.log(endTime);
        }

        // A line following the year slected
        // lineChart.append("line")
        //   .attr("id", "vert-line")
        //   .attr("x1", yearScale(year))
        //   .attr("y1", 0)
        //   .attr("x2", yearScale(year))
        //   .attr("y2", lineChartHeight + 5)
        //   .style("stroke-width", 2)
        //   .style("stroke", "grey")
        //   .style("fill", "none");

        lineChart.append("g") // year scale
          .attr("class", "x axis")
          .attr("transform", "translate(0," + (lineChartHeight + 5) + ")")
          .call(d3.axisBottom(d3.scaleTime()
            .domain([DEFAULT_DATE, year])
            .range([0, lineChartWidth])).ticks(12).tickSizeOuter(0).tickFormat(d3.format("d")))
          .call(g => g.selectAll(".tick line").attr("stroke-opacity", 0.4));

        // get the CO2 emission data and draw the bar representing the CO2 emission
        var co2;
        co2Data.forEach((d) => {
          if (year == d.Year) {
            co2 = d.CO2_concentrations;
          }
        })

        var co2Extent = d3.extent(co2Data, d => d.CO2_concentrations);
        const colorScale2 = d3.scaleSequential(d3.interpolateYlOrBr).domain([co2Extent[0] - 40, co2Extent[1]]); // color changes via the CO2 emission through years
        const lengthScale = d3.scaleLinear().domain(co2Extent).range([250, 450]); // length changes via the CO2 emission through years
        drawCO2Bar(co2, lengthScale, colorScale2)

        var updateco2Data = co2Data.filter(function (d) { return new Date(d.Year) <= new Date(year); });
        var updatetempData = tempDataAvgByYear.filter(function (d) { return new Date(d.year) <= new Date(year); });

        console.log(updateco2Data);
        console.log(updatetempData);

        var updateyearScale = d3.scaleTime()
          .domain(d3.extent(updateco2Data, d => d.Year))
          .range([0, lineChartWidth]);

        var updateco2Scale = d3.scaleLinear()
          .domain(d3.extent(updateco2Data, d => d.CO2_concentrations))
          .range([lineChartHeight, 0]);

        var updatetempScale = d3.scaleLinear()
          .domain(d3.extent(updatetempData, d => d.temperature))
          .range([lineChartHeight, 0]);

        lineChart.select("g.temp_axis").remove();
        lineChart.append("g")
          .attr("class", "temp_axis")
          .attr("transform", "translate(" + (lineChartWidth) + ",0)")
          .call(d3.axisRight(updatetempScale).tickSizeOuter(0).tickFormat(function (d) { return d3.format(",.2~f")(d) + "\u2103" }))
          .call(g => g.selectAll(".tick line").attr("stroke-opacity", 0));

        console.log(35 + "\u2103")

        lineChart.select("g.co2_axis").remove();
        lineChart.append("g")
          .attr("class", "co2_axis")
          // .attr("transform", "translate(0,-5)")
          .call(d3.axisLeft(updateco2Scale).tickSizeOuter(0).tickFormat(function (d) { return d + " ppm" }))
          .call(g => g.selectAll(".tick line").attr("stroke-opacity", 0));

        lineChart.select("path.temp_path").remove();
        lineChart.append("path").datum(updatetempData)
          .attr("class", "temp_path")
          .attr("fill", "none")
          .attr("stroke", "#69b3a2")
          .attr("stroke-width", 2)
          .attr("d", d3.line()
            .x(d => updateyearScale(d.year))
            .y(d => updatetempScale(d.temperature))
          );

        lineChart.select("path.co2_path").remove();
        lineChart.append("path").datum(updateco2Data)
          .attr("class", "co2_path")
          .attr("fill", "none")
          .attr("stroke", "#ed7325")
          .attr("stroke-width", 2)
          .attr("d", d3.line()
            .x(d => updateyearScale(d.Year))
            .y(d => updateco2Scale(d.CO2_concentrations))
          );

        lineChart.selectAll("circle.temp_circle").remove();
        lineChart.selectAll("temp_circle").data(updatetempData)
          .join("circle")
          .attr("class", "temp_circle")
          .attr("r", 3)
          .attr("fill", "#09604c")
          .attr("cx", d => updateyearScale(d.year))
          .attr("cy", d => updatetempScale(d.temperature));

        lineChart.selectAll("circle.co2circle").remove();
        lineChart.selectAll("co2circle").data(updateco2Data)
          .join("circle")
          .attr("class", "co2circle")
          .attr("r", 3)
          .attr("fill", "#823b0e")
          .attr("cx", d => updateyearScale(d.Year))
          .attr("cy", d => updateco2Scale(d.CO2_concentrations));

        lineChart.select("g.y.gridlines").remove();

        lineChart.append("g").lower()
          .attr("class", "y gridlines")
          // .attr("transform", "translate(-5,0)")
          .call(d3.axisLeft(updateco2Scale).tickFormat("").tickSize(-lineChartWidth));



        var country_avgTemp = {};
        curFilteredData = tempData.filter(function (d) {
          if (startMonth != null) {
            time = new Date(d.dt);
            return time >= startTime && time <= endTime;
          }
          return d.dt >= year && d.dt < year + 1;
        })
        curFilteredData.forEach((d, i) => {
          var country = d.Country;
          if (!(country in country_avgTemp)) {
            var temperature_list = [];
            temperature_list.push(d.AverageTemperature);
            country_avgTemp[country] = temperature_list;
          } else {
            temperature_list = country_avgTemp[country];
            temperature_list.push(d.AverageTemperature);
            country_avgTemp[country] = temperature_list;
          }
        });


        Object.keys(country_avgTemp).forEach(function (key) {
          temperature_list = country_avgTemp[key];
          var total = 0;
          for (i = 0; i < temperature_list.length; i++) {
            total += Number(temperature_list[i]);
          }
          country_avgTemp[key] = total / temperature_list.length;
        });

        //////////////////////////////////////1
        // Generate the data we will use
        var cnt = [];
        var idToCountry = {}  // idToCountry[ countryID ] -> CountryName

        // make a list of pairs of country names and its id, to fit the location in the geoJSON
        countries.features.forEach(row => {
          cnt.push({ id: row.id, name: row.properties.name })
          if (all_countries.indexOf(row.properties.name) != -1) {
            idToCountry[row.id] = row.properties.name;
          }
        });

        cnt.forEach(row => {
          Object.keys(country_avgTemp).forEach(function (key) {
            if (key === row.name) {
              row.temperature = country_avgTemp[key];
            }
          })
          row.temperature = Number(row.temperature)
          Object.keys(countries_temps).forEach(function (key) {
            if (key === row.name) {
              row.temp_mimMax = countries_temps[key];
            }
          })
        });

        // fiter out the data with no information on temperature and id
        cnt = cnt.filter(d => d['temperature'] && d['id']);

        cnt.forEach(row => {
          countryTemp[row.name] = row.temperature;
          countryMinMax[row.name] = row.temp_mimMax
        })



        // Make a d3 color scale for frequency    
        // var minMax = d3.extent(cnt, d => countryTemp[d.name]);

        var cScale = t => d3.interpolateRdBu(1 - t)
        var color = d3.scaleLinear().domain([10, 100]).range(["brown", "steelblue"]);
        var colorScale = d3.scaleSequential(colors).domain(minMax);

        map.selectAll(".country")
          .style("fill", d => {
            if (idToCountry[d.id]) {
              return d3.scaleQuantile()
                .domain(countryMinMax[idToCountry[d.id]])
                .range(colors)(countryTemp[idToCountry[d.id]]);
            }
          });

        // // Make a d3 color scale for frequency    
        // var minMax = d3.extent(cnt, d => countryTemp[d.name]);

        // var colors = ["#3c89d0", "#88c7dc", "#66c2a5", "#abdda4", "#e6f598", "#ffffbf", "#fee08b", "#fdae61", "#f46d43", "#d53e4f", "#9e0142"];

        // var colorScale = d3.scaleQuantile()
        //   .domain(Object.values(countryTemp))
        //   .range(colors);

        // // Recolor the states to make a choropleth map
        // map.selectAll(".country")
        //   .style("fill", d => colorScale(countryTemp[idToCountry[d.id]]));

        // // Use the extra legend code to draw a legend
        // drawLegend(d3.select("#colorLegend"), colorScale);

        // drawLegend(d3.select("#colorLegend"), colorScale);
      } // End of update function

      var startDate = new Date("1980-01-01"), endDate = new Date("2012-02-01");

      var svgSlider = d3.select("#slider")
        .append("svg")
        .attr("width", 1000)
        .attr("height", 70);

      var x = d3.scaleTime()
        .domain([startDate, endDate])
        .range([0, width])
        .clamp(true);

      var slider = svgSlider.append("g")
        .attr("class", "slider")
        .attr("transform", "translate(" + 25 + "," + 50 / 2 + ")");;

      slider.append("line")
        .attr("class", "track")
        .attr("x1", x.range()[0])
        .attr("x2", x.range()[1])
        .select(function () { return this.parentNode.appendChild(this.cloneNode(true)); })
        .attr("class", "track-inset")
        .select(function () { return this.parentNode.appendChild(this.cloneNode(true)); })
        .attr("class", "track-overlay")
        .call(d3.drag()
          .on("start.interrupt", function () { slider.interrupt(); })
          .on("start drag", function (event) {
            update(year = x.invert(event.x), startMonth = curStartMonth, endMonth = curEndMonth);
            curYear = x.invert(event.x)
          }));

      slider.insert("g", ".track-overlay")
        .attr("class", "ticks")
        .attr("transform", "translate(0," + 15 + ")")
        .selectAll("text")
        .data(x.ticks(17))
        .enter()
        .append("text")
        .attr("x", x)
        .attr("y", 10)
        .attr("text-anchor", "middle")
        .text(d=> formatDateIntoYear(d));

      var handle = slider.insert("circle", ".track-overlay")
        .attr("class", "handle")
        .attr("r", 9);

      var label = slider.append("text")
        .attr("class", "label")
        .attr("text-anchor", "middle")
        .text(Number(formatDateIntoYear(startDate)) + 1)
        .attr("transform", "translate(0," + (-15) + ")");

      d3.select('#winter').on('click', () => {
        curStartMonth = 0;
        curEndMonth = 3;
        update(year = curYear, startMonth = curStartMonth, endMonth = curEndMonth);
      });

      d3.select('#spring').on('click', () => {
        curStartMonth = 3;
        curEndMonth = 6;
        update(year = curYear, startMonth = curStartMonth, endMonth = curEndMonth);
      });

      d3.select('#summer').on('click', () => {
        curStartMonth = 6;
        curEndMonth = 8;
        update(year = curYear, startMonth = curStartMonth, endMonth = curEndMonth);
      });

      d3.select('#autumn').on('click', () => {
        curStartMonth = 8;
        curEndMonth = 11;
        update(year = curYear, startMonth = curStartMonth, endMonth = curEndMonth);
      });

      d3.select('#resetSeason').on('click', () => {
        curStartMonth = null;
        curEndMonth = null;
        update(year = curYear, startMonth = curStartMonth, endMonth = curEndMonth);
      });

      // d3.select('#spring').on('click', () => {
      //   svg.transition().call(zoom.scaleBy, 0.8)
      // });

      // d3.select('#spring').on('click', reset);

      // 3. Zoom-in & zoom-out features with the slider
      const zoom = d3.zoom() // initiate d3-zoom
        .scaleExtent([1, 5])
        .on("zoom", zoomed);

      svg.call(zoom);

      function zoomed(event) {
        const { transform } = event;
        map.attr("transform", transform);
        slider.property("value", transform.k);
      }


      // reset to original scale
      function reset() {
        svg.transition().duration(750).call(
          zoom.transform,
          d3.zoomIdentity,
          d3.zoomTransform(svg.node()).invert([mapWidth / 2, mapHeight / 2])
        );
      }

      // create a slider that zoom-in and zoom-out the map
      var slider = d3.select("#map-zoomer")
        .datum({})
        .attr("type", "range")
        .attr("value", zoom.scaleExtent()[0])
        .attr("min", zoom.scaleExtent()[0])
        .attr("max", zoom.scaleExtent()[1])
        .attr("step", (zoom.scaleExtent()[1] - zoom.scaleExtent()[0]) / 100)
        .on("input", slided);

      function slided(d) {
        svg.transition().call(zoom.scaleTo, d3.select(this).property("value"));
      }

      d3.select('#in').on('click', () => {
        svg.transition().call(zoom.scaleBy, 1.2)
      });

      d3.select('#out').on('click', () => {
        svg.transition().call(zoom.scaleBy, 0.8)
      });

      d3.select('#reset').on('click', reset);


      /////////////////////////////////////////////////
      // 3. Add tooltips to show the name of the country
      /////////////////////////////////////////////////

      var tip = d3.select(".tool_tip");

      let tooltip = tip.append("g")
        .attr("class", "tooltip")

      var frame = tooltip.append("rect").attr("class", "frame")
        // we style this in <head>
        .style("visibility", "hidden")
        .attr("x", 0).attr("y", 0)
        .attr("transform", "translate(53,0)")
        .attr("height", '90%');  // set width later

      const textbox = tooltip.append("g").attr("transform", "translate(10,10)");

      let txt1 = tooltip.append("text")
        .attr("fill", "black")
        .attr("text-anchor", "left")
        .attr("alignment-baseline", "hanging")
        .attr("x", 60)
        .attr("y", 10);

      let txt2 = tooltip.append("text")
        .attr("fill", "black")
        .attr("text-anchor", "left")
        .attr("alignment-baseline", "hanging")
        .attr("x", 60)
        .attr("y", 30);

      let txt3 = tooltip.append("text")
        .attr("fill", "black")
        .attr("text-anchor", "left")
        .attr("alignment-baseline", "hanging")
        .attr("x", 60)
        .attr("y", 50);

      // mouseover outline
      let momesh = map.append("path")
        .attr("class", "mouseover outline")
        .attr("d", "");

      d3.selectAll(".country").on("mouseenter", mouseEnters); // mouseover to show tooltips
      d3.selectAll(".country").on("mouseout", mouseLeaves)

      function mouseEnters() {
        // Make tooltip visible
        tooltip.style("visibility", "")
        frame.style("visibility", "")

        // Find the state SVG element and add stroke
        let country = d3.select(this);
        let countryID = country.datum().id;
        let countryName = country.datum().properties.name;

        //  First, make a new mesh with a filter for only borders of the current state
        var mo = topojson.mesh(world, world.objects.countries, function (a, b) { return a.id === countryID || b.id === countryID; });
        //  Then apply it to your special mesh that's on top of everything else
        momesh.datum(mo).attr("d", path)
        txt1.text(countryName)
        txt2.text("Temperature: " + countryTemp[idToCountry[countryID]] + "\u2103")
        txt3.text("History Min/Max: " + "[" + d3.extent(countryMinMax[idToCountry[countryID]])[0] + "\u2103," + d3.extent(countryMinMax[idToCountry[countryID]])[1] + "\u2103" + "]")
        // let bounds = path.bounds(country.datum());   // Get the pixel boundaries of the state
        // // Place it at the bottom of the state, centered
        // let xPos = (bounds[0][0] + bounds[1][0]) / 2.0;
        // let yPos = bounds[1][1];
        // // console.log(xPos, yPos)

        // // Transform the <g> group so that everything moves together easily
        // tooltip.attr("transform", `translate(${xPos},${yPos})`);
        tooltip.call(zoom);
      }

      function mouseLeaves() {
        // Hide when you leave a state
        tooltip.style("visibility", "hidden");
        let country = d3.select(this);
        // Reset old style mouseover stroke
        // state.attr("stroke","none")
        //      .attr("stroke-width", 0);
        // }
        // Here we are hiding the mouseover mesh we added at the end of the lecture
        momesh.attr("d", "");

      }








      // No counties this time


      // // Now import our fastfood dataset
      // var fastfood = await d3.csv("fastfood.csv", d3.autoType);
      // // console.log(fastfood)

      // // We're going to draw contours today. For contours, working by PIXEL
      // // coords rather than lat/lng is going to be the best approach 
      // // We do the same conversion as we did in the dot chart...
      // fastfood.forEach( (d, i) => {
      //   // Use the projection just like a scale to convert from lng/lat to pixels
      //   d.position = projection( [d.longitude, d.latitude] );
      //   // console.log(d.position)
      // });



      // // ** Make a contour generator **
      // // You'll see two kinds in the documentation, d3.contour() and d3.contourDensity
      // // -Use d3.contour when you have *values* spread across space and want to show them
      // // -Use contourDensity when you have *points* spread over space and want to show
      // //   *how many* there are in a given location compared to other locations
      // // Like other shape generators, you're programming a function that takes in a
      // //  dataset and does something fancy to it to generate shapes
      // let contourGen = d3.contourDensity()
      //                    .x( d => d.position[0] )        // point x position (best in pixels)
      //                    .y( d => d.position[1] )        // point y position (best in pixels)
      //                    .size( [width, height] )    // size of canvas
      //                    .thresholds( 10 );              // number of "levels" you want

      // // Now run the contour generator on your dataset
      // let contours = contourGen(fastfood);

      // // Check out what kind of data you get...
      // console.log(contours)
      // // It's actually a topoJSON featureCollection!
      // // A contour generator creates fake geographic data to use to draw contours
      // // We know how to work with these kinds of things...

      // // Let's make a color scale for the density contours
      // // Our topoJSON has an extra key for each feature, value, that is the density
      // //  value for that particular contour in the list -- we can use extent to figure
      // //  out the min and max density levels so we can apply a color scale
      // let valueExtent = d3.extent(contours, d => d.value);
      // let colorScale = d3.scaleSequential(d3.interpolateViridis).domain(valueExtent)

      // let layer = map.append("g");

      // // Sidenote: The array of features that contourDensity gives you have been carefully
      // //  ordered so that the big, low density ones will be earlier in the list -- this
      // //  guarantees that they'll be drawn *underneath* the higher densities in a join
      // layer.selectAll("path.contours")
      //       .data(contours)
      //       .join("path")
      //       .attr("class", 'contours')
      //       .attr("fill", d => colorScale(d.value) )
      //       .attr("d", d3.geoPath())  
      //         // NOTE: We create a new d3.geoPath because we have already converted our 
      //         //  locations into pixels. We don't need a projection in our geoPath now

      // // But how do we make sure the user can still see the map details and state borders?
      // // layer.attr("opacity", 0.5)   // This doesn't work too well to show map details...

      // // Better is to layer some stuff on top of the contours!
      // map.append("path").datum(countriesMesh)
      //       .attr("class","outline")
      //       .attr("opacity", 0.5)
      //       .attr("d", path);

      // // // We can show the circles to see whether our densities are plausible
      // // ffmap.selectAll("circle.dot").data(fastfood)
      // //      .join("circle")
      // //      .attr("class","dot")
      // //      .attr("r", 2)
      // //      .attr("fill", "darkgrey")
      // //      .attr("opacity", 0.2)
      // //      .attr("cx", d => d.position[0])
      // //      .attr("cy", d => d.position[1]);


    }
    requestData1();
  </script>

  <script>
    function drawCO2Bar(data, lengthScale, colorScale) {
      d3.select('#co2').datum(data)
        .attr("width", lengthScale(data))
        .style("background-color", colorScale(Number(data)));

      d3.select('#co2').append('text')
        .attr("x", "5")
        .attr("y", "18")
        .attr("fill", 'white')
        .text("CO2 Concentration: " + data + "ppm")
    }
    // Function needs a d3 selected SVG canvas where it will draw the legend and a source color scale
    function drawLegend(legend, legendColorScale) {
      //const legend = d3.select("#colorLegend");
      // invert the height and width becasue we need a rotated legend
      const legendWidth = legend.attr("height");
      const legendHeight = legend.attr("width");
      let legendMinMax = d3.extent(legendColorScale.domain()); // way to recover the minMax from most kinds of scales
      console.log(legendMinMax)
      const barHeight = 20;
      const stepSize = 6; // warning, not using a canvas element so lots of rect tags will be created for low stepSize, causing issues with performance
      // Extend the minmax by 1 in either direction to expose more features
      const pixelScale = d3.scaleLinear().domain([0, legendWidth - 40]).range([legendMinMax[0] - 1, legendMinMax[1] + 1]); // In this case the "data" are pixels, and we get numbers to use in colorScale
      const barScale = d3.scaleLinear().domain([legendMinMax[0] - 1, legendMinMax[1] + 1]).range([0, legendWidth - 40]);
      const barAxis = d3.axisBottom(barScale);
      // Check if we're using a quantile scale - if so, we can do better
      if (legendColorScale.hasOwnProperty('quantiles')) {
        // Use the quantile breakpoints plus the min and max of the scale as tick values
        barAxis.tickValues(legendColorScale.quantiles().concat(legendMinMax));
      }
      legend.append("g")
        .attr("class", "colorbar axis")
        .attr("transform", "rotate(" + 270 + " " + 560 + " " + 0 + ")" + "translate(" + (-46) + "," + (-490) + ")")

      let bar = legend.append("g")
        .attr("transform", "rotate(" + 270 + " " + 560 + " " + 0 + ")" + "translate(" + (-70) + "," + (-538) + ")")
      for (let i = 0; i < legendWidth - 40; i = i + stepSize) {
        bar.append("rect")
          .attr("x", i)
          .attr("y", 0)
          .attr("width", stepSize)
          .attr("height", barHeight)
          .style("fill", legendColorScale(pixelScale(i))); // pixels => countData => color
      }

      bar.append("text")
        .attr("class", "label")
        .attr("text-anchor", "end")
        .attr("x", 20)
        .attr("y", 5)
        .attr("dy", ".75em")
        .attr("transform", "rotate(90)")
        .text("Low");

      bar.append("text")
        .attr("class", "label")
        .attr("text-anchor", "end")
        .attr("x", 20)
        .attr("y", -630)
        .attr("dy", ".75em")
        .attr("transform", "rotate(90)")
        .text("High");

    }

  </script>
</body>

</html>