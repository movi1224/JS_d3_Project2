<html>

<head>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">
  <style>
    .country {
      fill: gray;
    }

    .outline {
      stroke: #fff;
      stroke-width: 1px;
      fill: none;
    }

    .mouseover {
      stroke-width: 3px;
      pointer-events: none;
    }

    .graticule {
      stroke: #ddd;
      stroke-width: 1px;
      fill: none;
    }

    #map {
      float: left;
      display: inline;
    }

    #legend {
      /* margin-left: 10px; */
      float: left;
      display: inline;
    }

    #float-button-group {
      position: fixed;
      left: 10;
      opacity: 0.5;
    }

    #float-button-group:hover {
      opacity: 1;
    }

    #season-button-group {
      position: fixed;
      left: 1200;
      opacity: 0.5;
    }

    #season-button-group:hover {
      opacity: 1;
    }

    #map-zoomer {
      position: absolute;
      writing-mode: bt-lr;
      -webkit-appearance: slider-vertical;
      width: 8px;
      height: 100px;
      padding: 0 5px;
      position: absolute;
      top: 205px;
      left: 25px;
    }

    .ticks {
      font-size: 10px;
    }

    .track
    .track-inset,
    .track-overlay {
      stroke-linecap: round;
    }

    .track {
      stroke: #000;
      stroke-opacity: 0.3;
      stroke-width: 10px;
    }

    .track-inset {
      stroke: #dcdcdc;
      stroke-width: 8px;
    }

    .track-overlay {
      pointer-events: stroke;
      stroke-width: 50px;
      stroke: transparent;
      cursor: crosshair;
    }

    .handle {
      fill: #fff;
      stroke: #000;
      stroke-opacity: 0.5;
      stroke-width: 1.25px;
    }

  </style>
</head>

<body>
  <p>Project2</p>

  <div id="slider"></div>
  <div id="map">
    <div class="btn-group-vertical" role="group" id="float-button-group">
      <button type="button" class="btn btn-default" id="in"><span class="glyphicon glyphicon-zoom-in"
          aria-hidden="true"></span></button>
      <button type="button" class="btn btn-default" id="out"><span class="glyphicon glyphicon-zoom-out"
          aria-hidden="true"></span></button>
      <button type="button" class="btn btn-default" id="reset"><span class="glyphicon glyphicon-screenshot"
          aria-hidden="true"></span></button>
    </div>
    <input type="range" value="1" min="1" max="8" orient="vertical" id="map-zoomer" />
    <svg id="worldmap" height="610" width="960"></svg>
  </div>

  <div id="legend">
    <svg id="colorLegend" height="600" width="200" style="background: #fff;"></svg>
  </div>

  <div class="btn-group-horizontal" role="group" id="season-button-group">
    <button type="button" class="btn btn-default" id="winter"><span
        aria-hidden="true">Jan-Mar</span></button>
    <button type="button" class="btn btn-default" id="spring"><span
        aria-hidden="true">Apr-June</span></button>
    <button type="button" class="btn btn-default" id="summer"><span 
        aria-hidden="true">Jul-Sep</span></button>
    <button type="button" class="btn btn-default" id="autumn"><span 
        aria-hidden="true">Oct-Dec</span></button>
    <button type="button" class="btn btn-default" id="resetSeason"><span 
      aria-hidden="true">Whole Year</span></button>
  </div>

  <script>
    // World map
    const svg = d3.select("#worldmap");
    const width = svg.attr("width");
    const height = svg.attr("height");
    const mapWidth = width;
    const mapHeight = height;
    // No margins here since our US map already has a specific projection to match to size
    const map = svg.append("g");

    // Format the date in the data
    var formatDateIntoYear = d3.timeFormat("%Y");
    var formatDate = d3.timeFormat("%b %Y");
    var parseDate = d3.timeParse("%y-%m-%d");
    const DEFAULT_DATE = formatDateIntoYear(new Date("1980-02-01"));
    var curYear = new Date("1980-02-01");
    var curStartMonth = null;
    var curEndMonth = null;

    const requestData1 = async function () {

      ///////////////////////////////////////////////// 
      // 1. Draw a map of all countries using topoJSON
      /////////////////////////////////////////////////

      // Import topoJSON data file
      const world = await d3.json("countries-110m.json");

      // Pick out topographic features and build d3 helpers
      var countries = topojson.feature(world, world.objects.countries);
      var countriesMesh = topojson.mesh(world, world.objects.countries);
      var projection = d3.geoNaturalEarth1() //geoMercator() //geoNaturalEarth1
      var path = d3.geoPath().projection(projection);

      var graticule = d3.geoGraticule10();       // Add a graticule
      map.append("path").attr("class", "graticule").attr("d", path(graticule));

      // Draw countries and outlines
      map.selectAll("path.country").data(countries.features)  // countries
        .join("path")
        .attr("class", "country")
        .attr("id", d => d.id)
        // .on("click", clicked)
        .attr("d", path);

      map.append("path").datum(countriesMesh) // outlines
        .attr("class", "outline")
        .attr("d", path);

      /////////////////////////////////////////////////
      // 2. Import temperature data
      /////////////////////////////////////////////////
      var tempData = await d3.csv("Temperatures.csv");

      tempData = tempData.filter(d => d['AverageTemperature'] !== ""); // filter out blank data
      // console.log(tempData)
      tempData.sort((x, y) => {
        return d3.ascending(x.Country, y.Country);
      })

      var all_countries = [];
      var country_avgTemp = {};

      // var  = formatDateIntoYear("1980-07-01");
      // tempData.forEach((d, i) => {
      //   // get all countries in this data
      //   if (d.Country != all_countries[0]) {
      //     all_countries.splice(0, 0, d.Country);
      //   }

      //   if (d.dt >= DEFAULT_DATE && d.dt < DEFAULT_DATE+2) {
      //     data.push(d);
      //   }
      // })

      curFilteredData = tempData.filter(function(d) {
          return d.dt >= DEFAULT_DATE && d.dt < DEFAULT_DATE+1;
        })
        // let filterFunc = d => d["dt"] <= data;
        // tempData = tempData.filter( d => pointPassesFilters(d) ); 
        curFilteredData.forEach((d, i) => {
          var country  = d.Country;
          // make a list of all the countries
          if (country != all_countries[0]) {
            all_countries.splice(0, 0, country);
          }
          // make a map of each country and a list of all its temperatures in a year 
          if (!(country in country_avgTemp)){
            // take all the temperatrues of a country in a  list
            var temperature_list = [];
            temperature_list.push(d.AverageTemperature);
            country_avgTemp[country] = temperature_list;
          }else{
            temperature_list = country_avgTemp[country];
            temperature_list.push(d.AverageTemperature);
            country_avgTemp[country] = temperature_list;
          }
        });
        console.log(country_avgTemp)

      // Use the temperature list to calculate the average temperature in a year of each country
      Object.keys(country_avgTemp).forEach(function(key) {
          temperature_list = country_avgTemp[key];
          var total = 0;
          for (i = 0; i < temperature_list.length; i++) {
            total += Number(temperature_list[i]);
          }
          country_avgTemp[key] = total / temperature_list.length;
      });

      // Generate the data we will use
      var countryCounts = {}; // countryCounts[ countryName ] -> count
      var cnt = [];
      var idToCountry = {}  // idToCountry[ countryID ] -> CountryName

      // make a list of pairs of country names and its id, to fit the location in the geoJSON
      countries.features.forEach(row => {
        cnt.push({ id: row.id, name: row.properties.name })
        countryCounts[row.properties.name] = 0;
        idToCountry[row.id] = row.properties.name;
      });

      cnt.forEach(row => {
          Object.keys(country_avgTemp).forEach(function(key) {
            if (key === row.name) {
              row.temperature = country_avgTemp[key];
            }
          })
          row.temperature = Number(row.temperature)
      })

      // fiter out the data with no information on temperature and id
      cnt = cnt.filter(d => d['temperature'] && d['id']);

      console.log(cnt)
      console.log(countryCounts)
      cnt.forEach(row => {
        countryCounts[row.name] = row.temperature;
      })


      // Make a d3 color scale for frequency    
      console.log(tempData);
      // Make a d3 color scale for frequency    
      var minMax =  d3.extent(cnt, d => countryCounts[d.name]);

      var colors = ["#3c89d0", "#88c7dc", "#66c2a5", "#abdda4", "#e6f598", "#ffffbf", "#fee08b", "#fdae61", "#f46d43", "#d53e4f", "#9e0142"];

      var colorScale = d3.scaleQuantile()
        .domain(Object.values(countryCounts))
        .range(colors);

      // Recolor the states to make a choropleth map
      map.selectAll(".country")
        .style("fill", d => colorScale(countryCounts[idToCountry[d.id]]));

      // Use the extra legend code to draw a legend
      drawLegend(d3.select("#colorLegend"), colorScale);

      function changeMonthDays(d, qty) {
          var dd = d.getDate();
          var mm = d.getMonth();
          var yyyy = d.getFullYear();
          return new Date(yyyy, qty, 1);
      }

      function updateTemparature(year, startMonth = undefined, endMonth = undefined) {
        d3.select('#colorLegend')
          .selectAll('*')
          .remove();   

        handle.attr("cx", x(year));


        if (startMonth != null){
          startTime = changeMonthDays(year,startMonth);
          endTime = changeMonthDays(year,endMonth);
          year = formatDateIntoYear(year);
          label.attr("x", x(year)).text(year);
          console.log(startTime);
          console.log(endTime);
        }else{
          year = formatDateIntoYear(year);
          label.attr("x", x(year)).text(year);
          console.log(year);
        }

        var all_countries = [];
        var country_avgTemp = {};
        console.log(new Date(tempData[0].dt) < year);
        curFilteredData = tempData.filter(function(d) {
          if (startMonth!= null){
            time = new Date(d.dt);
            return time >= startTime && time <= endTime;
          }
          return d.dt >= year && d.dt < year + 1;
        })
        console.log(curFilteredData)
        // let filterFunc = d => d["dt"] <= data;
        // tempData = tempData.filter( d => pointPassesFilters(d) ); 
        curFilteredData.forEach((d, i) => {
          var country  = d.Country;
          if (country != all_countries[0]) {
            all_countries.splice(0, 0, country);
          }
          if (!(country in country_avgTemp)){
            var temperature_list = [];
            temperature_list.push(d.AverageTemperature);
            country_avgTemp[country] = temperature_list;
          }else{
            temperature_list = country_avgTemp[country];
            temperature_list.push(d.AverageTemperature);
            country_avgTemp[country] = temperature_list;
          }
        });


        Object.keys(country_avgTemp).forEach(function(key) {
          temperature_list = country_avgTemp[key];
          var total = 0;
          for (i = 0; i < temperature_list.length; i++) {
            total += Number(temperature_list[i]);
          }
          country_avgTemp[key] = total / temperature_list.length;
        });




        var countryCounts = {}; // countryCounts[ countryName ] -> count
        var cnt = [];
        var idToCountry = {}  // idToCountry[ countryID ] -> CountryName


        countries.features.forEach(row => {
          cnt.push({ id: row.id, name: row.properties.name })
          countryCounts[row.properties.name] = 0;
          idToCountry[row.id] = row.properties.name;
        });

        cnt.forEach(row => {
          Object.keys(country_avgTemp).forEach(function(key) {
            if (key === row.name) {
              row.temperature = country_avgTemp[key];
            }
          })
          row.temperature = Number(row.temperature)
        })
        
        cnt = cnt.filter(d => d['temperature'] && d['id']);


        cnt.forEach(row => {
          countryCounts[row.name] = row.temperature;
        })



        // Make a d3 color scale for frequency    
        var minMax =  d3.extent(cnt, d => countryCounts[d.name]);

        var colors = ["#3c89d0", "#88c7dc", "#66c2a5", "#abdda4", "#e6f598", "#ffffbf", "#fee08b", "#fdae61", "#f46d43", "#d53e4f", "#9e0142"];

        var colorScale = d3.scaleQuantile()
          .domain(Object.values(countryCounts))
          .range(colors);

        // Recolor the states to make a choropleth map
        map.selectAll(".country")
          .style("fill", d => colorScale(countryCounts[idToCountry[d.id]]));

        // Use the extra legend code to draw a legend
        drawLegend(d3.select("#colorLegend"), colorScale);
      
      }




      var startDate = new Date("1980-02-01"), endDate = new Date("2012-12-01");

      var svgSlider = d3.select("#slider")
        .append("svg")
        .attr("width", 1000)
        .attr("height", 70);
    
      var x = d3.scaleTime()
          .domain([startDate, endDate])
          .range([0, width])
          .clamp(true);






      var slider = svgSlider.append("g")
          .attr("class", "slider")
          .attr("transform", "translate(" + 25 + "," + 50 / 2 + ")");;

      slider.append("line")
          .attr("class", "track")
          .attr("x1", x.range()[0])
          .attr("x2", x.range()[1])
        .select(function() { return this.parentNode.appendChild(this.cloneNode(true)); })
          .attr("class", "track-inset")
        .select(function() { return this.parentNode.appendChild(this.cloneNode(true)); })
          .attr("class", "track-overlay")
          .call(d3.drag()
              .on("start.interrupt", function() { slider.interrupt(); })
              .on("start drag", function(event) { 
                updateTemparature(year=x.invert(event.x),startMonth=curStartMonth,endMonth = curEndMonth); 
                curYear = x.invert(event.x)}));

      slider.insert("g", ".track-overlay")
          .attr("class", "ticks")
          .attr("transform", "translate(0," + 18 + ")")
        .selectAll("text")
          .data(x.ticks(16))
          .enter()
          .append("text")
          .attr("x", x)
          .attr("y", 10)
          .attr("text-anchor", "middle")
          .text(function(d) { 
            return formatDateIntoYear(d); });

      var handle = slider.insert("circle", ".track-overlay")
          .attr("class", "handle")
          .attr("r", 9);

      var label = slider.append("text")  
          .attr("class", "label")
          .attr("text-anchor", "middle")
          .text(formatDateIntoYear(startDate))
          .attr("transform", "translate(0," + (-15) + ")");



      d3.select('#winter').on('click', () => {
        curStartMonth = 0;
        curEndMonth = 3;
        updateTemparature(year = curYear, startMonth = curStartMonth, endMonth = curEndMonth);
      });
      
      d3.select('#spring').on('click', () => {
        curStartMonth = 3;
        curEndMonth = 6;
        updateTemparature(year = curYear, startMonth = curStartMonth, endMonth = curEndMonth);
      });




      d3.select('#summer').on('click', () => {
        curStartMonth = 6;
        curEndMonth = 8;
        updateTemparature(year = curYear, startMonth = curStartMonth, endMonth = curEndMonth);
      });

      d3.select('#autumn').on('click', () => {
        curStartMonth = 8;
        curEndMonth = 11;
        updateTemparature(year = curYear, startMonth = curStartMonth, endMonth = curEndMonth);
      });

      d3.select('#resetSeason').on('click', () => {
        curStartMonth = null;
        curEndMonth = null;
        updateTemparature(year = curYear, startMonth = curStartMonth, endMonth = curEndMonth);
      });

      // d3.select('#spring').on('click', () => {
      //   svg.transition().call(zoom.scaleBy, 0.8)
      // });

      // d3.select('#spring').on('click', reset);






      // 3. Zoom-in & zoom-out features with the slider
      const zoom = d3.zoom() // initiate d3-zoom
        .scaleExtent([1, 5])
        .on("zoom", zoomed);

      svg.call(zoom);

      function zoomed(event) {
        const { transform } = event;
        map.attr("transform", transform);
        slider.property("value", transform.k);
      }


      // reset to original scale
      function reset() {
        svg.transition().duration(750).call(
          zoom.transform,
          d3.zoomIdentity,
          d3.zoomTransform(svg.node()).invert([mapWidth / 2, mapHeight / 2])
        );
      }

      // create a slider that zoom-in and zoom-out the map
      var slider = d3.select("#map-zoomer")
        .datum({})
        .attr("type", "range")
        .attr("value", zoom.scaleExtent()[0])
        .attr("min", zoom.scaleExtent()[0])
        .attr("max", zoom.scaleExtent()[1])
        .attr("step", (zoom.scaleExtent()[1] - zoom.scaleExtent()[0]) / 100)
        .on("input", slided);

      function slided(d) {
        svg.transition().call(zoom.scaleTo, d3.select(this).property("value"));
      }

      d3.select('#in').on('click', () => {
        svg.transition().call(zoom.scaleBy, 1.2)
      });

      d3.select('#out').on('click', () => {
        svg.transition().call(zoom.scaleBy, 0.8)
      });

      d3.select('#reset').on('click', reset);


      /////////////////////////////////////////////////
      // 3. Add tooltips to show the name of the country
      /////////////////////////////////////////////////

      let tooltipWidth = 120;
      let tooltipHeight = 40;

      let tooltip = map.append("g")
        .attr("class", "tooltip")
        .attr("visibility", "hidden");

      tooltip.append("rect")
        .attr("fill", "black")
        .attr("opacity", 0.9)
        .attr("x", -tooltipWidth / 2.0)
        .attr("y", 0)
        .attr("width", tooltipWidth)
        .attr("height", tooltipHeight);

      let txt = tooltip.append("text")
        .attr("fill", "white")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 0)
        .attr("y", 2);

      // mouseover outline
      let momesh = map.append("path")
        .attr("class", "mouseover outline")
        .attr("d", "");

      d3.selectAll(".country").on("mouseenter", mouseEnters); // mouseover to show tooltips
      d3.selectAll(".country").on("mouseout", mouseLeaves)

      function mouseEnters() {
        // Make tooltip visible
        tooltip.style("visibility", "visible")
        // Find the state SVG element and add stroke
        let country = d3.select(this);
        let ctID = country.datum().id;
        let ctName = country.datum().properties.name;
        // console.log(country.datum().properties.name)
        //  First, make a new mesh with a filter for only borders of the current state
        var mo = topojson.mesh(world, world.objects.countries, function (a, b) { return a.id === ctID || b.id === ctID; });
        //  Then apply it to your special mesh that's on top of everything else
        momesh.datum(mo).attr("d", path)
        txt.text(ctName);

        let bounds = path.bounds(country.datum());   // Get the pixel boundaries of the state
        // Place it at the bottom of the state, centered
        let xPos = (bounds[0][0] + bounds[1][0]) / 2.0;
        let yPos = bounds[1][1];
        // console.log(xPos, yPos)

        // Transform the <g> group so that everything moves together easily
        tooltip.attr("transform", `translate(${xPos},${yPos})`);
        tooltip.call(zoom);
      }

      function mouseLeaves() {
        // Hide when you leave a state
        tooltip.style("visibility", "hidden");
        let country = d3.select(this);
        // Reset old style mouseover stroke
        // state.attr("stroke","none")
        //      .attr("stroke-width", 0);
        // }
        // Here we are hiding the mouseover mesh we added at the end of the lecture
        momesh.attr("d", "");

      }








      // No counties this time


      // // Now import our fastfood dataset
      // var fastfood = await d3.csv("fastfood.csv", d3.autoType);
      // // console.log(fastfood)

      // // We're going to draw contours today. For contours, working by PIXEL
      // // coords rather than lat/lng is going to be the best approach 
      // // We do the same conversion as we did in the dot chart...
      // fastfood.forEach( (d, i) => {
      //   // Use the projection just like a scale to convert from lng/lat to pixels
      //   d.position = projection( [d.longitude, d.latitude] );
      //   // console.log(d.position)
      // });



      // // ** Make a contour generator **
      // // You'll see two kinds in the documentation, d3.contour() and d3.contourDensity
      // // -Use d3.contour when you have *values* spread across space and want to show them
      // // -Use contourDensity when you have *points* spread over space and want to show
      // //   *how many* there are in a given location compared to other locations
      // // Like other shape generators, you're programming a function that takes in a
      // //  dataset and does something fancy to it to generate shapes
      // let contourGen = d3.contourDensity()
      //                    .x( d => d.position[0] )        // point x position (best in pixels)
      //                    .y( d => d.position[1] )        // point y position (best in pixels)
      //                    .size( [width, height] )    // size of canvas
      //                    .thresholds( 10 );              // number of "levels" you want

      // // Now run the contour generator on your dataset
      // let contours = contourGen(fastfood);

      // // Check out what kind of data you get...
      // console.log(contours)
      // // It's actually a topoJSON featureCollection!
      // // A contour generator creates fake geographic data to use to draw contours
      // // We know how to work with these kinds of things...

      // // Let's make a color scale for the density contours
      // // Our topoJSON has an extra key for each feature, value, that is the density
      // //  value for that particular contour in the list -- we can use extent to figure
      // //  out the min and max density levels so we can apply a color scale
      // let valueExtent = d3.extent(contours, d => d.value);
      // let colorScale = d3.scaleSequential(d3.interpolateViridis).domain(valueExtent)

      // let layer = map.append("g");

      // // Sidenote: The array of features that contourDensity gives you have been carefully
      // //  ordered so that the big, low density ones will be earlier in the list -- this
      // //  guarantees that they'll be drawn *underneath* the higher densities in a join
      // layer.selectAll("path.contours")
      //       .data(contours)
      //       .join("path")
      //       .attr("class", 'contours')
      //       .attr("fill", d => colorScale(d.value) )
      //       .attr("d", d3.geoPath())  
      //         // NOTE: We create a new d3.geoPath because we have already converted our 
      //         //  locations into pixels. We don't need a projection in our geoPath now

      // // But how do we make sure the user can still see the map details and state borders?
      // // layer.attr("opacity", 0.5)   // This doesn't work too well to show map details...

      // // Better is to layer some stuff on top of the contours!
      // map.append("path").datum(countriesMesh)
      //       .attr("class","outline")
      //       .attr("opacity", 0.5)
      //       .attr("d", path);

      // // // We can show the circles to see whether our densities are plausible
      // // ffmap.selectAll("circle.dot").data(fastfood)
      // //      .join("circle")
      // //      .attr("class","dot")
      // //      .attr("r", 2)
      // //      .attr("fill", "darkgrey")
      // //      .attr("opacity", 0.2)
      // //      .attr("cx", d => d.position[0])
      // //      .attr("cy", d => d.position[1]);


    }
    requestData1();
  </script>

  <script>
    // Function needs a d3 selected SVG canvas where it will draw the legend and a source color scale
    function drawLegend(legend, legendColorScale) {
      //const legend = d3.select("#colorLegend");
      // invert the height and width becasue we need a rotated legend
      const legendWidth = legend.attr("height");
      const legendHeight = legend.attr("width");
      let legendMinMax = d3.extent(legendColorScale.domain()); // way to recover the minMax from most kinds of scales
      console.log(legendMinMax)
      const barHeight = 20;
      const stepSize = 4; // warning, not using a canvas element so lots of rect tags will be created for low stepSize, causing issues with performance
      // Extend the minmax by 1 in either direction to expose more features
      const pixelScale = d3.scaleLinear().domain([0, legendWidth - 40]).range([legendMinMax[0] - 1, legendMinMax[1] + 1]); // In this case the "data" are pixels, and we get numbers to use in colorScale
      const barScale = d3.scaleLinear().domain([legendMinMax[0] - 1, legendMinMax[1] + 1]).range([0, legendWidth - 40]);
      const barAxis = d3.axisBottom(barScale);
      // Check if we're using a quantile scale - if so, we can do better
      if (legendColorScale.hasOwnProperty('quantiles')) {
        // Use the quantile breakpoints plus the min and max of the scale as tick values
        barAxis.tickValues(legendColorScale.quantiles().concat(legendMinMax));
      }
      legend.append("g")
        .attr("class", "colorbar axis")
        .attr("transform", "rotate(" + 270 + " " + 560 + " " + 0 + ")" +  "translate(" + (-10) + "," + (-470) + ")")
        .call(barAxis);
      // Draw rects of color down the bar
      let bar = legend.append("g")
        .attr("transform", "rotate(" + 270 + " " + 560 + " " + 0 + ")" +  "translate(" + (-10) + "," + (-500) + ")")
      for (let i = 0; i < legendWidth - 40; i = i + stepSize) {
        bar.append("rect")
          .attr("x", i)
          .attr("y", 0)
          .attr("width", stepSize)
          .attr("height", barHeight)
          .style("fill", legendColorScale(pixelScale(i))); // pixels => countData => color
      }
      // Put lines in to mark actual min and max of our data
      bar.append("line").attr("stroke", "white").attr("stroke-width", 3).attr("x1", barScale(legendMinMax[0])).attr("x2", barScale(legendMinMax[0])).attr("y1", 0).attr("y1", barHeight + 4);
      bar.append("line").attr("stroke", "white").attr("stroke-width", 3).attr("x1", barScale(legendMinMax[1])).attr("x2", barScale(legendMinMax[1])).attr("y1", 0).attr("y1", barHeight + 4);
    }

  </script>
</body>

</html>